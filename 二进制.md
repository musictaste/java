#### 1.二进制整数  
    人为什么用十进制？  
    因为人的手指为10个指头  
      
    计算机为什么用二进制
        cpu，外面又引脚，有的时候是高电频，有的是低电频；用0，1进行表示
      
    十进制和二进制表数的共同点：基数(Radix)
         十进制的基数为10
         二进制的基数为2
         作业：了解基数排序

#### 2.二进制与10进制的转换
    
    计算：基数*位次幂之和
    
    举例：十进制：315=3*10²+1*10¹+5*10º

        二级制：0110=0*2³+1*2²+1*2¹+0*2º=6

        五进制：43 = 4*5¹+3*5º=23

        八进制：047=4*8¹+7*8º=39
          注：八进制以0开头

        十六进制：0xAF=10*16¹+15*16º=175
          注：十六进制以‘0x’开头，值为：0----9，A,B,C,D,E,F
          A=10,F=15
          
      二进制转10进制
         01101011=64+32+8+2+1=107
         
      十进制转二进制：
        方法一：除2取余法（教科书）
        ![image](https://raw.githubusercontent.com/musictaste/java/master/image/11.png)
        
        方法二：（简便方法）
            记住2¹º内的值
            2¹º=1024    512   256  128  64  32  16  8  4  2 1
            举例：114=64+32+16+2=01110010
                153=128+16+8+1
####   3.源码/反码/补码  
    最高位变成符号位
    
    原码：表示正数
    反码：
    补码：表示负数
    
    举例：7的原码：00000111
        反码：11111000
        补码：取反+1,11111001
        
    负数用补码表示，十进制负责转二进制：先求解对应正数，然后符号位为1，其余位取反+1  
        举例-17转二进制
            正数17的原码：00010001
            符号位变1，其余位取反：11101110
            补码：11101111
            
            -7转二进制
                正数7的原码：00000111
                符号位变1，其余位取反：11111000
                加1，变成补码：11111001
                
         八位的表示范围：-128~127 
     
    二进制负数转十进制，符号位不变，其余位取反+1，得到原码
        举例：1100 0100转十进制
            符号位不变，其余位取反：1011 1011
            加1:1011 1100=32+16+8+4=-60
                
            -60转二进制
                60的原码：0011 1100
                符号位为1，其余位取反：1100 0011
                加1:1100 0100（二进制）
     
    为什么负数用补码表示？
        1.减法可以当做加法来运算
            举例：5-2
            5： 0000 0101
            3： 0000 0011
                1111 1100
            -3: 1111 1101
            
            5+（-3）=0000 0101
                     1111 1101
                    =0 0000 0010(溢出)
                    =0000 0010
                    =2
            
        2.0的表述实现统一
            0的原码：0000 0000
            0符号位为1，其余位取反：1111 1111
            加1，变成补码：0 0000 0000
            溢出，补码为：0000 0000
            
#### 4 二进制逻辑运算(bitwise operation)
    
    面试重灾区
    
    & 遇0则0
        1&1=1  1&0=0  0&0=0
        
    | 遇1则1
        1|1=1  1|0=1  0|0=0
        
    ~ 取反  1-0  0-1
    
    ^ 异或  不进位加（相同为0，相异为1）（常考）
        1^1=0  0^0=0  1^0=1
    
    >> 右移 补符号位
        最低位移除，最高位根据原先的最高位补
        0100 1001   >> 0010  0100
        1100 1001   >> 1110  0100
    << 左移 补0
        最高位移除，最低位永远不0
        0100 1001 <<  1001 0010
        0100 1001 <<  1001 0010
        
        移位运算与乘除运算的关系
        
     >>> 无符号右移 补0
  
    举例：8---0000 1000
        右移：0000 0100=4
            右移，对于正整数，是除2
        
            注：对于负整数的自己了解，也是除1
        
             左移，对于正整数，乘2
             
     面试题：1.怎么算2³？
        最快的方法：2<<2（2左移两位）
      
     面试题：2：a=3,b=4,a和b怎么交换数值？(比较难)
        a=a^b
        b=a^b
        a=a^b
        
        验证： a=0011  b=0100
        a=a^b=0011 ^ 0100= 0111
        b=a^b=0111 ^ 0100 = 0011
        a=a^b=0111 ^ 0011= 0100
  
#### 5长整数与短整数的转换
    
    短整数转成长整数，前面补符号位
        举例：0110 1101---->  0000 0000 0110 1101(16位)
        1100 0110 ---->  1111 1111 1100 0110
  
     长整数转短整数,计算机的做法，把前面的位数砍掉，会出现精度丢失
        
####   6 常用说法
    
    bit(b)         1024倍增
    Byte
    KB
    MB
    GB
    TB
    
####   7 big/little endian
    
    大端与小端
    超过一个字节的数在内存中的存储顺序
    低位在小地址--little endian，操作系统采用
    高位在小地址--big endian,网络传输采用
    举例：
      a b c d 
      大端：d
            c
            b
            a
            
    那么通过网络传输的字节，到操作系统后，会进行大小端的转换，计算机底层已经帮助实现  
    
***
###   总结：
     1.二进制、八进制、10进制、16进制的转换
        基数*位次幂之和
        
        除2取余法
       
     2.原码、反码、补码
        负数用补码表示，十进制负责转二进制：先求解对应正数，然后符号位为1，其余位取反+1
        
        二进制负数转十进制，符号位不变，其余位取反+1，得到原码
       
     3.位运算：&  |  ~   ^   >>  <<  >>>
        面试题：1.怎么算2³？
        面试题：2：a=3,b=4,a和b怎么交换数值？
         
     4.长短类型转换
     5.计数单位：bit  byte  KB  MB  GB  TB
     6.bit/little endian
  
